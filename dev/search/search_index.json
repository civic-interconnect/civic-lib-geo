{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Interconnect Project Documentation","text":"<p>Welcome to the documentation hub for Civic Interconnect (CI) projects.</p> <p>Use the navigation menu to explore available modules, APIs, and tools.</p> <p>For more information, visit the Civic Interconnect GitHub organization.</p>"},{"location":"DEVELOPER/","title":"DEVELOPER.md","text":""},{"location":"DEVELOPER/#prerequisites-set-up-machine","title":"Prerequisites: Set Up Machine","text":"<ul> <li>View hidden files and folders</li> <li>View file extensions</li> <li>Git</li> <li>VS Code (recommended)</li> <li>uv</li> </ul>"},{"location":"DEVELOPER/#fork-and-clone-repository","title":"Fork and Clone Repository","text":"<ol> <li>Fork the repo.</li> <li>Clone your repo to your machine and open it in VS Code.</li> </ol> <p>Open a terminal and run the following commands. <pre><code>git clone https://github.com/civic-interconnect/civic-lib-geo.git\ncd civic-lib-geo\n</code></pre></p>"},{"location":"DEVELOPER/#dev-1-one-time-setup","title":"Dev 1. One-time setup","text":"<ul> <li>Open the repo directory in VS Code.</li> <li>Open a terminal in VS Code (examples use PowerShell commands on Windows machine).</li> </ul> <pre><code>uv python pin 3.12\nuv venv\n\n.venv\\Scripts\\activate # Windows\n# source .venv/bin/activate  # Mac/Linux/WSL\n\nuv sync --extra dev --extra docs --upgrade\nuv run pre-commit install\n</code></pre>"},{"location":"DEVELOPER/#dev-2-validate-local-changes","title":"Dev 2. Validate Local Changes","text":"<pre><code>git pull origin main\nuvx pre-commit autoupdate\ngit add .\nuvx ruff check . --fix\nuvx ruff format .\nuvx deptry .\nuvx pyright\nuv run pytest\n</code></pre> <p>Run the project hooks (twice, if needed):</p> <pre><code>uv run pre-commit run --all-files\n</code></pre>"},{"location":"DEVELOPER/#dev-3-build-and-inspect-package","title":"DEV 3. Build and Inspect Package","text":"<pre><code>uv build\n\n$TMP = New-Item -ItemType Directory -Path ([System.IO.Path]::GetTempPath()) -Name (\"wheel_\" + [System.Guid]::NewGuid())\nExpand-Archive dist\\*.whl -DestinationPath $TMP.FullName\nGet-ChildItem -Recurse $TMP.FullName | ForEach-Object { $_.FullName.Replace($TMP.FullName + '\\','') }\nRemove-Item -Recurse -Force $TMP\n</code></pre>"},{"location":"DEVELOPER/#dev-4-build-and-preview-docs","title":"DEV 4. Build and Preview Docs","text":"<pre><code>uv run mkdocs build --strict\nuv run mkdocs serve\n</code></pre> <p>Verify local API docs at: http://localhost:8000 When done reviewing, use CTRL c or CMD c to quit.</p>"},{"location":"DEVELOPER/#dev-5-clean-artifacts-optional","title":"DEV 5. Clean Artifacts (Optional)","text":"<pre><code>Get-ChildItem -Path . -Recurse -Directory -Filter \"*__pycache__*\" | Remove-Item -Recurse -Force\nGet-ChildItem -Path . -Recurse -Directory -Filter \".*_cache\"  | Remove-Item -Recurse -Force\nGet-ChildItem -Path \"src\" -Recurse -Directory -Name \"*.egg-info\" | Remove-Item -Recurse -Force\nRemove-Item -Path \"build\", \"dist\", \"site\" -Recurse -Force\n</code></pre>"},{"location":"DEVELOPER/#dev-6-test","title":"DEV 6. Test","text":"<p>Update <code>CHANGELOG.md</code> and <code>pyproject</code>.toml dependencies. Ensure CI passes.</p> <pre><code>uv run pre-commit run --all-files\nuv run pytest -q\n</code></pre>"},{"location":"DEVELOPER/#dev-7-git-add-commit-push-changes","title":"DEV 7. Git add-commit-push Changes","text":"<pre><code>git add .\ngit commit -m \"Prep vx.y.z\"\ngit push -u origin main\n</code></pre>"},{"location":"DEVELOPER/#dev-8-git-tag-and-push-tag","title":"DEV 8. Git tag and Push tag","text":"<p>Important: Wait for GitHub Actions from prior step to complete successfully (all green checks). If any fail, fix issues and push again before tagging.</p> <pre><code>git tag vx.y.z -m \"x.y.z\"\ngit push origin vx.y.z\n</code></pre> <p>A GitHub Action will build, publish to PyPI (Trusted Publishing), create a GitHub Release with artifacts, and deploy versioned docs with <code>mike</code>.</p> <p>You do not need to run <code>gh release create</code> or upload files manually.</p>"},{"location":"api/","title":"API Reference","text":"<p>Auto-generated code documentation.</p>"},{"location":"api/#civic_lib_geo","title":"civic_lib_geo","text":""},{"location":"api/#civic_lib_geo.__main__","title":"__main__","text":"<p>Entry point for Civic Lib Geo CLI.</p> <p>File: civic_lib_geo.main</p>"},{"location":"api/#civic_lib_geo.cli","title":"cli","text":""},{"location":"api/#civic_lib_geo.cli.check_size","title":"check_size","text":"<p>check_size.py.</p> <p>Check the size of a GeoJSON file and whether it exceeds GitHub Pages limits.</p> Used by civic-geo CLI <p>civic-geo check-size"},{"location":"api/#civic_lib_geo.cli.check_size.main","title":"main","text":"<pre><code>main(path: Path) -&gt; int\n</code></pre> <p>Print the size of a GeoJSON file and whether it exceeds GitHub Pages limits.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the GeoJSON file to inspect.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>0 if OK, 1 if an error occurs.</p> Source code in <code>src/civic_lib_geo/cli/check_size.py</code> <pre><code>def main(path: Path) -&gt; int:\n    \"\"\"Print the size of a GeoJSON file and whether it exceeds GitHub Pages limits.\n\n    Args:\n        path (Path): Path to the GeoJSON file to inspect.\n\n    Returns:\n        int: 0 if OK, 1 if an error occurs.\n    \"\"\"\n    try:\n        path = Path(path)  # Defensive cast\n        size_mb = get_file_size_mb(path)\n        logger.info(f\"File size: {size_mb:.2f} MB\")\n\n        if needs_chunking(path):\n            logger.warning(\"File exceeds 25MB GitHub Pages limit. Consider chunking.\")\n        else:\n            logger.info(\"File is within acceptable size limits.\")\n        return 0\n    except Exception as e:\n        logger.error(f\"Error checking file size: {e}\")\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.chunk_geojson","title":"chunk_geojson","text":"<p>chunk_geojson.py.</p> <p>Utility to split a GeoJSON FeatureCollection into smaller files.</p> Used by civic-geo CLI <p>civic-geo chunk path/to/file.geojson --max-features 500 civic-geo chunk path/to/folder --all-files</p>"},{"location":"api/#civic_lib_geo.cli.chunk_geojson.chunk_one","title":"chunk_one","text":"<pre><code>chunk_one(path: Path, max_features: int, output_dir: Path)\n</code></pre> <p>Chunk a single GeoJSON file and write the output files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to input GeoJSON file.</p> required <code>max_features</code> <code>int</code> <p>Max features per chunk.</p> required <code>output_dir</code> <code>Path</code> <p>Output folder to store chunks.</p> required Source code in <code>src/civic_lib_geo/cli/chunk_geojson.py</code> <pre><code>def chunk_one(path: Path, max_features: int, output_dir: Path):\n    \"\"\"Chunk a single GeoJSON file and write the output files.\n\n    Args:\n        path (Path): Path to input GeoJSON file.\n        max_features (int): Max features per chunk.\n        output_dir (Path): Output folder to store chunks.\n    \"\"\"\n    try:\n        geojson_dict = json.loads(path.read_text(encoding=\"utf-8\"))\n        chunk_paths = chunk_geojson_features(\n            geojson=geojson_dict,\n            max_features=max_features,\n            output_dir=output_dir,\n            base_name=path.stem + \"_chunk\",\n        )\n        logger.info(f\"Wrote {len(chunk_paths)} chunks to {output_dir}\")\n    except Exception as e:\n        logger.error(f\"Error chunking {path}: {e}\")\n        raise\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.chunk_geojson.main","title":"main","text":"<pre><code>main(path: Path, max_features: int = 500, output_dir: Path = Path('chunks'), all_files: bool = False) -&gt; int\n</code></pre> <p>Chunk a single file or all .geojson files in a folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Input file or folder path.</p> required <code>max_features</code> <code>int</code> <p>Max features per chunk.</p> <code>500</code> <code>output_dir</code> <code>Path</code> <p>Directory to store chunks.</p> <code>Path('chunks')</code> <code>all_files</code> <code>bool</code> <p>If True and path is a folder, chunk all files in it.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code, 0 if success, 1 if failure.</p> Source code in <code>src/civic_lib_geo/cli/chunk_geojson.py</code> <pre><code>def main(\n    path: Path,\n    max_features: int = 500,\n    output_dir: Path = Path(\"chunks\"),\n    all_files: bool = False,\n) -&gt; int:\n    \"\"\"Chunk a single file or all .geojson files in a folder.\n\n    Args:\n        path (Path): Input file or folder path.\n        max_features (int): Max features per chunk.\n        output_dir (Path): Directory to store chunks.\n        all_files (bool): If True and path is a folder, chunk all files in it.\n\n    Returns:\n        int: Exit code, 0 if success, 1 if failure.\n    \"\"\"\n    try:\n        if path.is_dir():\n            if not all_files:\n                logger.error(\n                    \"Provided path is a directory. Use --all-files to process all files in it.\"\n                )\n                return 1\n\n            apply_to_geojson_folder(\n                folder=path,\n                action_fn=chunk_one,\n                suffix=\"_chunked.geojson\",\n                max_features=max_features,\n            )\n        else:\n            chunk_one(path, max_features, output_dir)\n\n        return 0\n    except Exception:\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli","title":"cli","text":"<p>cli.py.</p> <p>Command-line interface (CLI) for civic-lib-geo.</p> <p>Provides repo-specific commands for: - Chunking - Simplifying - Property inspection - File size checks</p> <p>Run <code>civic-geo --help</code> for usage.</p>"},{"location":"api/#civic_lib_geo.cli.cli.check_size_command","title":"check_size_command","text":"<pre><code>check_size_command(path: Path)\n</code></pre> <p>Report the size of a GeoJSON file and whether it exceeds the GitHub Pages 25MB limit.</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>@app.command(\"check-size\")\n@app.command(\"size\")\ndef check_size_command(path: Path):\n    \"\"\"Report the size of a GeoJSON file and whether it exceeds the GitHub Pages 25MB limit.\"\"\"\n    from . import check_size\n\n    check_size.main(path)\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli.chunk_command","title":"chunk_command","text":"<pre><code>chunk_command(folder: Path = FOLDER_ARG, max_features: int = 500, single_file: Path = SINGLE_FILE_OPT)\n</code></pre> <p>Chunk a GeoJSON file or all files in a folder into smaller files with limited features.</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>@app.command(\"chunk-geojson\")\n@app.command(\"chunk\")\ndef chunk_command(\n    folder: Path = FOLDER_ARG,\n    max_features: int = 500,\n    single_file: Path = SINGLE_FILE_OPT,\n):\n    \"\"\"Chunk a GeoJSON file or all files in a folder into smaller files with limited features.\"\"\"\n    from . import chunk_geojson\n\n    if single_file:\n        chunk_geojson.main(single_file, max_features)\n    else:\n        geojson_utils.apply_to_geojson_folder(\n            folder, chunk_geojson.main, max_features=max_features, suffix=\"_chunked.geojson\"\n        )\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli.main","title":"main","text":"<pre><code>main() -&gt; int\n</code></pre> <p>Run the main entry point for the CLI application.</p> <p>This function serves as the primary entry point for the command-line interface. It initializes and runs the app, then returns a success status code.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit status code (0 for success).</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Run the main entry point for the CLI application.\n\n    This function serves as the primary entry point for the command-line interface.\n    It initializes and runs the app, then returns a success status code.\n\n    Returns:\n        int: Exit status code (0 for success).\n    \"\"\"\n    app()\n    return 0\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli.props_command","title":"props_command","text":"<pre><code>props_command(path: Path)\n</code></pre> <p>Display the property keys from the first feature of a GeoJSON file.</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>@app.command(\"read-props\")\ndef props_command(path: Path):\n    \"\"\"Display the property keys from the first feature of a GeoJSON file.\"\"\"\n    from . import read_props\n\n    read_props.main(path)\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli.shapefile_to_geojson_command","title":"shapefile_to_geojson_command","text":"<pre><code>shapefile_to_geojson_command(shp_path: Path, geojson_path: Path)\n</code></pre> <p>Convert a shapefile to GeoJSON.</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>@app.command(\"shapefile-to-geojson\")\n@app.command(\"shp-to-geo\")\ndef shapefile_to_geojson_command(shp_path: Path, geojson_path: Path):\n    \"\"\"Convert a shapefile to GeoJSON.\"\"\"\n    from . import shapefile_to_geojson\n\n    shapefile_to_geojson.main(shp_path, geojson_path)\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli.simplify_command","title":"simplify_command","text":"<pre><code>simplify_command(folder: Path = FOLDER_ARG, tolerance: float = 0.01, single_file: Path = SINGLE_FILE_OPT)\n</code></pre> <p>Simplify one GeoJSON file or all files in a folder using the given tolerance.</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>@app.command(\"simplify-geojson\")\n@app.command(\"simplify\")\ndef simplify_command(\n    folder: Path = FOLDER_ARG,\n    tolerance: float = 0.01,\n    single_file: Path = SINGLE_FILE_OPT,\n):\n    \"\"\"Simplify one GeoJSON file or all files in a folder using the given tolerance.\"\"\"\n    from . import simplify_geojson\n\n    if single_file:\n        simplify_geojson.main(single_file, tolerance)\n    else:\n        geojson_utils.apply_to_geojson_folder(\n            folder, simplify_geojson.main, tolerance=tolerance, suffix=\"_simplified.geojson\"\n        )\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.cli.topojson_to_geojson_command","title":"topojson_to_geojson_command","text":"<pre><code>topojson_to_geojson_command(topo_path: Path, geojson_path: Path)\n</code></pre> <p>Convert a TopoJSON file to GeoJSON using GeoPandas (if supported).</p> Source code in <code>src/civic_lib_geo/cli/cli.py</code> <pre><code>@app.command(\"topojson-to-geojson\")\n@app.command(\"topo-to-geo\")\ndef topojson_to_geojson_command(topo_path: Path, geojson_path: Path):\n    \"\"\"Convert a TopoJSON file to GeoJSON using GeoPandas (if supported).\"\"\"\n    from . import topojson_to_geojson\n\n    logger.warning(\"\u26a0\ufe0f TopoJSON support depends on GDAL. Consider using mapshaper if this fails.\")\n    topojson_to_geojson.main(topo_path, geojson_path)\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.read_props","title":"read_props","text":"<p>read_props.py.</p> <p>Command-line utility to preview feature properties in one or more GeoJSON files.</p> <p>Displays the <code>.properties</code> dictionary for the first few features in each file. Useful for inspecting available fields before cleaning, chunking, or simplifying.</p> <p>Supports: - A single file: <code>civic-geo read-props file.geojson</code> - A folder of files: <code>civic-geo read-props data/ --all-files</code></p>"},{"location":"api/#civic_lib_geo.cli.read_props.main","title":"main","text":"<pre><code>main(path: Path, all_files: bool = False) -&gt; int\n</code></pre> <p>Display feature properties for a single file or all .geojson files in a folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>File or folder path.</p> required <code>all_files</code> <code>bool</code> <p>If True and path is a folder, process all .geojson files inside.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>0 if success, 1 on error.</p> Source code in <code>src/civic_lib_geo/cli/read_props.py</code> <pre><code>def main(path: Path, all_files: bool = False) -&gt; int:\n    \"\"\"Display feature properties for a single file or all .geojson files in a folder.\n\n    Args:\n        path (Path): File or folder path.\n        all_files (bool): If True and path is a folder, process all .geojson files inside.\n\n    Returns:\n        int: 0 if success, 1 on error.\n    \"\"\"\n    try:\n        if path.is_dir():\n            if not all_files:\n                logger.error(\n                    \"Provided path is a directory. Use --all-files to process all files in it.\"\n                )\n                return 1\n            apply_to_geojson_folder(\n                folder=path,\n                action_fn=read_props_one,\n                suffix=\"\",  # No new file written\n            )\n        else:\n            read_props_one(path)\n        return 0\n    except Exception:\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.read_props.read_props_one","title":"read_props_one","text":"<pre><code>read_props_one(path: Path, output: Path | None = None, max_rows: int = 5)\n</code></pre> <p>Print properties from the first few features in a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the GeoJSON file.</p> required <code>output</code> <code>Path | None</code> <p>Ignored in this function (kept for compatibility).</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Number of feature properties to preview.</p> <code>5</code> Source code in <code>src/civic_lib_geo/cli/read_props.py</code> <pre><code>def read_props_one(path: Path, output: Path | None = None, max_rows: int = 5):\n    \"\"\"Print properties from the first few features in a GeoJSON file.\n\n    Args:\n        path (Path): Path to the GeoJSON file.\n        output (Path | None): Ignored in this function (kept for compatibility).\n        max_rows (int): Number of feature properties to preview.\n    \"\"\"\n    try:\n        props = read_geojson_props(path)\n        logger.info(f\"{path.name}: {len(props)} features loaded\")\n\n        for i, row in enumerate(props[:max_rows], 1):\n            print(f\"\\nFeature {i}:\")\n            for key, value in row.items():\n                print(f\"  {key}: {value}\")\n        if len(props) &gt; max_rows:\n            print(f\"\\n... and {len(props) - max_rows} more.\")\n    except Exception as e:\n        logger.error(f\"Error reading properties from {path}: {e}\")\n        raise\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.shapefile_to_geojson","title":"shapefile_to_geojson","text":"<p>shapefile_to_geojson.py.</p> <p>Command-line utility to convert a shapefile to GeoJSON.</p> Used by <p>civic-geo shapefile-to-geojson SHAPEFILE_PATH GEOJSON_PATH</p>"},{"location":"api/#civic_lib_geo.cli.shapefile_to_geojson.main","title":"main","text":"<pre><code>main(shp_path: Path, geojson_path: Path) -&gt; int\n</code></pre> <p>Convert a shapefile to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>shp_path</code> <code>Path</code> <p>Input .shp file path.</p> required <code>geojson_path</code> <code>Path</code> <p>Output .geojson file path.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>0 if success, 1 on error.</p> Source code in <code>src/civic_lib_geo/cli/shapefile_to_geojson.py</code> <pre><code>def main(shp_path: Path, geojson_path: Path) -&gt; int:\n    \"\"\"Convert a shapefile to GeoJSON.\n\n    Args:\n        shp_path (Path): Input .shp file path.\n        geojson_path (Path): Output .geojson file path.\n\n    Returns:\n        int: 0 if success, 1 on error.\n    \"\"\"\n    try:\n        shapefile_utils.convert_shapefile_to_geojson(shp_path, geojson_path)\n        logger.info(f\"Converted {shp_path} to {geojson_path}\")\n        return 0\n    except Exception as e:\n        logger.error(f\"Error converting shapefile: {e}\")\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.simplify_geojson","title":"simplify_geojson","text":"<p>simplify_geojson.py.</p> <p>Command-line utility to simplify the geometry of one or more GeoJSON files.</p> <p>Reduces geometry complexity using a specified tolerance and saves the simplified output to a new file. When given a directory with --all-files, all <code>.geojson</code> files will be processed.</p> Usage <p>civic-geo simplify path/to/file.geojson civic-geo simplify path/to/folder --all-files</p>"},{"location":"api/#civic_lib_geo.cli.simplify_geojson.main","title":"main","text":"<pre><code>main(path: Path, tolerance: float = 0.01, output: Path | None = None, all_files: bool = False)\n</code></pre> <p>Simplify a single file or all .geojson files in a folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Input file or folder.</p> required <code>tolerance</code> <code>float</code> <p>Simplification tolerance.</p> <code>0.01</code> <code>output</code> <code>Path | None</code> <p>Output file path for single file use.</p> <code>None</code> <code>all_files</code> <code>bool</code> <p>If True and path is a folder, simplify all .geojson files.</p> <code>False</code> Source code in <code>src/civic_lib_geo/cli/simplify_geojson.py</code> <pre><code>def main(\n    path: Path,\n    tolerance: float = 0.01,\n    output: Path | None = None,\n    all_files: bool = False,\n):\n    \"\"\"Simplify a single file or all .geojson files in a folder.\n\n    Args:\n        path (Path): Input file or folder.\n        tolerance (float): Simplification tolerance.\n        output (Path | None): Output file path for single file use.\n        all_files (bool): If True and path is a folder, simplify all .geojson files.\n    \"\"\"\n    if path.is_dir():\n        if not all_files:\n            logger.error(\n                \"Provided path is a directory. Use --all-files to process all files in it.\"\n            )\n            raise SystemExit(1)\n        apply_to_geojson_folder(\n            folder=path,\n            action_fn=simplify_one,\n            suffix=\"_simplified.geojson\",\n            tolerance=tolerance,\n        )\n    else:\n        out = output or path.with_name(path.stem + \"_simplified.geojson\")\n        simplify_one(path, tolerance, out)\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.simplify_geojson.simplify_one","title":"simplify_one","text":"<pre><code>simplify_one(path: Path, tolerance: float, output: Path)\n</code></pre> <p>Simplify a single GeoJSON file and write the output.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the original GeoJSON file.</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for simplification.</p> required <code>output</code> <code>Path</code> <p>Output path for the simplified file.</p> required Source code in <code>src/civic_lib_geo/cli/simplify_geojson.py</code> <pre><code>def simplify_one(path: Path, tolerance: float, output: Path):\n    \"\"\"Simplify a single GeoJSON file and write the output.\n\n    Args:\n        path (Path): Path to the original GeoJSON file.\n        tolerance (float): Tolerance for simplification.\n        output (Path): Output path for the simplified file.\n    \"\"\"\n    try:\n        gdf = load_geojson(path)\n        logger.info(f\"Loaded {len(gdf)} features from {path}\")\n        simplified = simplify_geojson(gdf, tolerance)\n        save_geojson(simplified, output)\n        logger.info(f\"Simplified saved to: {output}\")\n    except Exception as e:\n        logger.error(f\"Error simplifying {path}: {e}\")\n        raise SystemExit(1) from e\n</code></pre>"},{"location":"api/#civic_lib_geo.cli.topojson_to_geojson","title":"topojson_to_geojson","text":"<p>topojson_to_geojson.py.</p> <p>Command-line utility to convert a TopoJSON file to GeoJSON.</p> Used by <p>civic-geo topojson-to-geojson TOPOJSON_PATH GEOJSON_PATH</p>"},{"location":"api/#civic_lib_geo.cli.topojson_to_geojson.main","title":"main","text":"<pre><code>main(topo_path: Path, geojson_path: Path) -&gt; int\n</code></pre> <p>Convert a TopoJSON file to GeoJSON using GeoPandas (if supported).</p> <p>Parameters:</p> Name Type Description Default <code>topo_path</code> <code>Path</code> <p>Input .topojson file path.</p> required <code>geojson_path</code> <code>Path</code> <p>Output .geojson file path.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>0 if success, 1 if failure.</p> Source code in <code>src/civic_lib_geo/cli/topojson_to_geojson.py</code> <pre><code>def main(topo_path: Path, geojson_path: Path) -&gt; int:\n    \"\"\"Convert a TopoJSON file to GeoJSON using GeoPandas (if supported).\n\n    Args:\n        topo_path (Path): Input .topojson file path.\n        geojson_path (Path): Output .geojson file path.\n\n    Returns:\n        int: 0 if success, 1 if failure.\n    \"\"\"\n    try:\n        import geopandas as gpd\n\n        gdf = gpd.read_file(topo_path)\n        gdf.to_file(geojson_path, driver=\"GeoJSON\")\n        logger.info(f\"Converted {topo_path} to {geojson_path}\")\n        return 0\n    except Exception as e:\n        logger.error(f\"TopoJSON conversion failed: {e}\")\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_geo.fips_utils","title":"fips_utils","text":"<p>civic_lib_geo/fips_utils.py.</p> <p>Utilities for working with FIPS codes.</p> <p>MIT License \u2014 maintained by Civic Interconnect</p>"},{"location":"api/#civic_lib_geo.fips_utils.get_fips_by_state_code","title":"get_fips_by_state_code","text":"<pre><code>get_fips_by_state_code(state_code: str, source: Path | None = None) -&gt; str\n</code></pre> <p>Return the FIPS code for a given 2-letter state code.</p> <p>Parameters:</p> Name Type Description Default <code>state_code</code> <code>str</code> <p>A 2-letter state abbreviation (e.g., 'MN').</p> required <code>source</code> <code>Path | None</code> <p>Optional override path to a custom CSV file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Corresponding FIPS code (e.g., '27').</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the state code is not found.</p> Source code in <code>src/civic_lib_geo/fips_utils.py</code> <pre><code>def get_fips_by_state_code(state_code: str, source: Path | None = None) -&gt; str:\n    \"\"\"Return the FIPS code for a given 2-letter state code.\n\n    Args:\n        state_code (str): A 2-letter state abbreviation (e.g., 'MN').\n        source (Path | None): Optional override path to a custom CSV file.\n\n    Returns:\n        str: Corresponding FIPS code (e.g., '27').\n\n    Raises:\n        ValueError: If the state code is not found.\n    \"\"\"\n    df = get_state_fips_df(source)\n    result = df[df[\"state_code\"].str.upper() == state_code.upper()]\n    if result.empty:\n        raise ValueError(f\"State code '{state_code}' not found in FIPS data.\")\n    return result.iloc[0][\"fips_code\"]\n</code></pre>"},{"location":"api/#civic_lib_geo.fips_utils.get_state_fips_df","title":"get_state_fips_df","text":"<pre><code>get_state_fips_df(source: Path | None = None) -&gt; pd.DataFrame\n</code></pre> <p>Load and return a DataFrame of US state FIPS codes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path | None</code> <p>Path to a CSV file. If None, uses the default embedded CSV.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame with columns ['state_code', 'state_name', 'fips_code'].</p> Source code in <code>src/civic_lib_geo/fips_utils.py</code> <pre><code>def get_state_fips_df(source: Path | None = None) -&gt; pd.DataFrame:\n    \"\"\"Load and return a DataFrame of US state FIPS codes.\n\n    Args:\n        source (Path | None): Path to a CSV file. If None, uses the default embedded CSV.\n\n    Returns:\n        pd.DataFrame: A DataFrame with columns ['state_code', 'state_name', 'fips_code'].\n    \"\"\"\n    if source is None:\n        source = Path(__file__).parent / \"data\" / \"us-state-fips.csv\"\n    df = read_csv_from_path(source)\n    df.columns = [col.strip().lower() for col in df.columns]\n\n    expected = {\"state_code\", \"state_name\", \"fips_code\"}\n    if not expected.issubset(df.columns):\n        raise ValueError(f\"Missing expected columns. Found: {df.columns}\")\n\n    return df\n</code></pre>"},{"location":"api/#civic_lib_geo.fips_utils.get_state_name_by_code","title":"get_state_name_by_code","text":"<pre><code>get_state_name_by_code(state_code: str, source: Path | None = None) -&gt; str\n</code></pre> <p>Return the full state name for a given 2-letter state code.</p> <p>Parameters:</p> Name Type Description Default <code>state_code</code> <code>str</code> <p>A 2-letter state abbreviation.</p> required <code>source</code> <code>Path | None</code> <p>Optional override path to a custom CSV file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Full state name (e.g., 'Minnesota').</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the state code is not found.</p> Source code in <code>src/civic_lib_geo/fips_utils.py</code> <pre><code>def get_state_name_by_code(state_code: str, source: Path | None = None) -&gt; str:\n    \"\"\"Return the full state name for a given 2-letter state code.\n\n    Args:\n        state_code (str): A 2-letter state abbreviation.\n        source (Path | None): Optional override path to a custom CSV file.\n\n    Returns:\n        str: Full state name (e.g., 'Minnesota').\n\n    Raises:\n        ValueError: If the state code is not found.\n    \"\"\"\n    df = get_state_fips_df(source)\n    result = df[df[\"state_code\"].str.upper() == state_code.upper()]\n    if result.empty:\n        raise ValueError(f\"State code '{state_code}' not found in FIPS data.\")\n    return result.iloc[0][\"state_name\"]\n</code></pre>"},{"location":"api/#civic_lib_geo.fips_utils.read_csv_from_path","title":"read_csv_from_path","text":"<pre><code>read_csv_from_path(source: Path) -&gt; pd.DataFrame\n</code></pre> <p>Read a CSV file from the given path and returns a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Path</code> <p>Path to the CSV file.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the CSV data.</p> Source code in <code>src/civic_lib_geo/fips_utils.py</code> <pre><code>def read_csv_from_path(source: Path) -&gt; pd.DataFrame:\n    \"\"\"Read a CSV file from the given path and returns a DataFrame.\n\n    Args:\n        source (Path): Path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the CSV data.\n    \"\"\"\n    return pd.read_csv(source, dtype=str)\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils","title":"geojson_utils","text":"<p>civic_lib_geo/geojson_utils.py.</p> <p>GeoJSON utility functions for Civic Interconnect.</p> <p>MIT License \u2014 maintained by Civic Interconnect</p>"},{"location":"api/#civic_lib_geo.geojson_utils.apply_to_geojson_folder","title":"apply_to_geojson_folder","text":"<pre><code>apply_to_geojson_folder(folder: Path, action_fn: Callable, *, suffix: str = '_processed.geojson', tolerance: float | None = None, max_features: int | None = None)\n</code></pre> <p>Apply an action to every .geojson file in a folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Path</code> <p>Path to folder containing .geojson files.</p> required <code>action_fn</code> <code>Callable</code> <p>Function to apply to each file.</p> required <code>suffix</code> <code>str</code> <p>Suffix to add to output filenames.</p> <code>'_processed.geojson'</code> <code>tolerance</code> <code>float | None</code> <p>Optional tolerance value for simplification.</p> <code>None</code> <code>max_features</code> <code>int | None</code> <p>Optional limit for chunking.</p> <code>None</code> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def apply_to_geojson_folder(\n    folder: Path,\n    action_fn: Callable,\n    *,\n    suffix: str = \"_processed.geojson\",\n    tolerance: float | None = None,\n    max_features: int | None = None,\n):\n    \"\"\"Apply an action to every .geojson file in a folder.\n\n    Args:\n        folder (Path): Path to folder containing .geojson files.\n        action_fn (Callable): Function to apply to each file.\n        suffix (str): Suffix to add to output filenames.\n        tolerance (float | None): Optional tolerance value for simplification.\n        max_features (int | None): Optional limit for chunking.\n    \"\"\"\n    files = list(folder.glob(\"*.geojson\"))\n    if not files:\n        logger.warning(f\"No .geojson files found in {folder}\")\n        return\n\n    logger.info(f\"Found {len(files)} GeoJSON file(s) in {folder}\")\n    for file in files:\n        output_path = file.with_name(file.stem + suffix)\n        try:\n            logger.info(f\"Processing {file.name}\")\n            if tolerance is not None:\n                action_fn(file, tolerance, output_path)\n            elif max_features is not None:\n                action_fn(file, max_features, output_path)\n            else:\n                action_fn(file, output_path)\n        except Exception as e:\n            logger.error(f\"Failed to process {file.name}: {e}\")\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.chunk_geojson_features","title":"chunk_geojson_features","text":"<pre><code>chunk_geojson_features(geojson: dict, max_features: int = 500, output_dir: str | Path = 'chunks', base_name: str = 'chunk') -&gt; list[Path]\n</code></pre> <p>Split a GeoJSON FeatureCollection into multiple smaller files.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>Loaded GeoJSON dictionary (must contain a 'features' list).</p> required <code>max_features</code> <code>int</code> <p>Maximum number of features per chunk.</p> <code>500</code> <code>output_dir</code> <code>str | Path</code> <p>Directory to write chunked files to.</p> <code>'chunks'</code> <code>base_name</code> <code>str</code> <p>Base filename prefix for each chunk.</p> <code>'chunk'</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of Paths to chunked files.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'features' is missing or not a list.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def chunk_geojson_features(\n    geojson: dict,\n    max_features: int = 500,\n    output_dir: str | Path = \"chunks\",\n    base_name: str = \"chunk\",\n) -&gt; list[Path]:\n    \"\"\"Split a GeoJSON FeatureCollection into multiple smaller files.\n\n    Args:\n        geojson: Loaded GeoJSON dictionary (must contain a 'features' list).\n        max_features: Maximum number of features per chunk.\n        output_dir: Directory to write chunked files to.\n        base_name: Base filename prefix for each chunk.\n\n    Returns:\n        List of Paths to chunked files.\n\n    Raises:\n        ValueError: If 'features' is missing or not a list.\n    \"\"\"\n    if \"features\" not in geojson or not isinstance(geojson[\"features\"], list):\n        raise ValueError(\"Invalid GeoJSON: missing or malformed 'features' array.\")\n\n    features = geojson[\"features\"]\n    total = len(features)\n    logger.info(f\"Splitting {total} features into chunks of {max_features}\")\n\n    output_dir = Path(output_dir)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    chunks_written = []\n    for i in range(0, total, max_features):\n        chunk = {\"type\": \"FeatureCollection\", \"features\": features[i : i + max_features]}\n        chunk_path = output_dir / f\"{base_name}_{i // max_features + 1}.geojson\"\n        try:\n            with chunk_path.open(\"w\", encoding=\"utf-8\") as f:\n                json.dump(chunk, f, ensure_ascii=False, indent=2)\n            logger.info(f\"Wrote {len(chunk['features'])} features to {chunk_path}\")\n            chunks_written.append(chunk_path)\n        except Exception as e:\n            logger.error(f\"Failed to write chunk to {chunk_path}: {e}\")\n            raise\n\n    return chunks_written\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.get_file_size_mb","title":"get_file_size_mb","text":"<pre><code>get_file_size_mb(path: str | Path) -&gt; float\n</code></pre> <p>Return the file size in megabytes (MB).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the file.</p> required <p>Returns:</p> Type Description <code>float</code> <p>File size in megabytes.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def get_file_size_mb(path: str | Path) -&gt; float:\n    \"\"\"Return the file size in megabytes (MB).\n\n    Args:\n        path: Path to the file.\n\n    Returns:\n        File size in megabytes.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n    \"\"\"\n    path = Path(path)\n    if not path.is_file():\n        raise FileNotFoundError(f\"File not found: {path}\")\n    size_mb = path.stat().st_size / (1024 * 1024)\n    logger.debug(f\"File size of '{path}': {size_mb:.2f} MB\")\n    return size_mb\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.is_valid_geojson_feature_collection","title":"is_valid_geojson_feature_collection","text":"<pre><code>is_valid_geojson_feature_collection(obj: dict) -&gt; bool\n</code></pre> <p>Quick check if an object looks like a valid GeoJSON FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict</code> <p>Dictionary to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid structure, else False.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def is_valid_geojson_feature_collection(obj: dict) -&gt; bool:\n    \"\"\"Quick check if an object looks like a valid GeoJSON FeatureCollection.\n\n    Args:\n        obj: Dictionary to check.\n\n    Returns:\n        True if valid structure, else False.\n    \"\"\"\n    return (\n        isinstance(obj, dict)\n        and obj.get(\"type\") == \"FeatureCollection\"\n        and isinstance(obj.get(\"features\"), list)\n    )\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.list_geojson_files","title":"list_geojson_files","text":"<pre><code>list_geojson_files(folder: Path) -&gt; list[Path]\n</code></pre> <p>Return a list of .geojson files in the specified folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Path</code> <p>Directory to search.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: List of .geojson file paths.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def list_geojson_files(folder: Path) -&gt; list[Path]:\n    \"\"\"Return a list of .geojson files in the specified folder.\n\n    Args:\n        folder (Path): Directory to search.\n\n    Returns:\n        list[Path]: List of .geojson file paths.\n    \"\"\"\n    return list(folder.glob(\"*.geojson\"))\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.load_geojson","title":"load_geojson","text":"<pre><code>load_geojson(path: Path) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Load a GeoJSON file into a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the GeoJSON file.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def load_geojson(path: Path) -&gt; gpd.GeoDataFrame:\n    \"\"\"Load a GeoJSON file into a GeoDataFrame.\n\n    Args:\n        path (Path): Path to the GeoJSON file.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.\n    \"\"\"\n    import geopandas as gpd\n\n    return gpd.read_file(path)\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.needs_chunking","title":"needs_chunking","text":"<pre><code>needs_chunking(path: str | Path, max_mb: float = 25.0) -&gt; bool\n</code></pre> <p>Determine whether the GeoJSON file exceeds the size threshold.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the file.</p> required <code>max_mb</code> <code>float</code> <p>Maximum file size before chunking is recommended.</p> <code>25.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if file exceeds max_mb, else False.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def needs_chunking(path: str | Path, max_mb: float = 25.0) -&gt; bool:\n    \"\"\"Determine whether the GeoJSON file exceeds the size threshold.\n\n    Args:\n        path: Path to the file.\n        max_mb: Maximum file size before chunking is recommended.\n\n    Returns:\n        True if file exceeds max_mb, else False.\n    \"\"\"\n    size_mb = get_file_size_mb(path)\n    needs_split = size_mb &gt; max_mb\n    logger.debug(f\"Needs chunking: {needs_split} (size: {size_mb:.2f} MB, limit: {max_mb} MB)\")\n    return needs_split\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.read_geojson_props","title":"read_geojson_props","text":"<pre><code>read_geojson_props(path: Path) -&gt; list[dict[str, Any]]\n</code></pre> <p>Load only the properties from a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the GeoJSON file.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: A list of property dictionaries from each feature.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def read_geojson_props(path: Path) -&gt; list[dict[str, Any]]:\n    \"\"\"Load only the properties from a GeoJSON file.\n\n    Args:\n        path (Path): Path to the GeoJSON file.\n\n    Returns:\n        list[dict[str, Any]]: A list of property dictionaries from each feature.\n    \"\"\"\n    with path.open(encoding=\"utf-8\") as f:\n        data = json.load(f)\n    return [feature[\"properties\"] for feature in data[\"features\"]]\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.save_geojson","title":"save_geojson","text":"<pre><code>save_geojson(gdf: GeoDataFrame, path: Path, indent: int = 2) -&gt; Path\n</code></pre> <p>Save a GeoDataFrame to GeoJSON format.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The GeoDataFrame to save.</p> required <code>path</code> <code>Path</code> <p>Output file path.</p> required <code>indent</code> <code>int</code> <p>Indentation level for formatting (unused by GeoPandas but included for consistency).</p> <code>2</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the saved file.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def save_geojson(gdf: \"gpd.GeoDataFrame\", path: Path, indent: int = 2) -&gt; Path:\n    \"\"\"Save a GeoDataFrame to GeoJSON format.\n\n    Args:\n        gdf (gpd.GeoDataFrame): The GeoDataFrame to save.\n        path (Path): Output file path.\n        indent (int): Indentation level for formatting (unused by GeoPandas but included for consistency).\n\n    Returns:\n        Path: The path to the saved file.\n    \"\"\"\n    gdf.to_file(path, driver=\"GeoJSON\")\n    return path\n</code></pre>"},{"location":"api/#civic_lib_geo.geojson_utils.simplify_geojson","title":"simplify_geojson","text":"<pre><code>simplify_geojson(gdf: GeoDataFrame, tolerance: float) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Return a simplified copy of the GeoDataFrame using the given tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The input GeoDataFrame.</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for simplification (smaller values retain more detail).</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A new GeoDataFrame with simplified geometry.</p> Source code in <code>src/civic_lib_geo/geojson_utils.py</code> <pre><code>def simplify_geojson(gdf: gpd.GeoDataFrame, tolerance: float) -&gt; gpd.GeoDataFrame:\n    \"\"\"Return a simplified copy of the GeoDataFrame using the given tolerance.\n\n    Args:\n        gdf (gpd.GeoDataFrame): The input GeoDataFrame.\n        tolerance (float): Tolerance for simplification (smaller values retain more detail).\n\n    Returns:\n        gpd.GeoDataFrame: A new GeoDataFrame with simplified geometry.\n    \"\"\"\n    return gdf.copy().assign(geometry=gdf.geometry.simplify(tolerance, preserve_topology=True))\n</code></pre>"},{"location":"api/#civic_lib_geo.shapefile_utils","title":"shapefile_utils","text":"<p>civic_lib_geo/shapefile_utils.py.</p> <p>Shapefile utility functions for Civic Interconnect.</p> <p>MIT License \u2014 maintained by Civic Interconnect</p>"},{"location":"api/#civic_lib_geo.shapefile_utils.convert_shapefile_to_geojson","title":"convert_shapefile_to_geojson","text":"<pre><code>convert_shapefile_to_geojson(shp_path: Path, geojson_path: Path) -&gt; Path\n</code></pre> <p>Convert a shapefile to a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>shp_path</code> <code>Path</code> <p>Path to the source shapefile (.shp).</p> required <code>geojson_path</code> <code>Path</code> <p>Path to the output GeoJSON file.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the saved GeoJSON file.</p> Source code in <code>src/civic_lib_geo/shapefile_utils.py</code> <pre><code>def convert_shapefile_to_geojson(shp_path: Path, geojson_path: Path) -&gt; Path:\n    \"\"\"Convert a shapefile to a GeoJSON file.\n\n    Args:\n        shp_path (Path): Path to the source shapefile (.shp).\n        geojson_path (Path): Path to the output GeoJSON file.\n\n    Returns:\n        Path: The path to the saved GeoJSON file.\n    \"\"\"\n    gdf = load_shapefile(shp_path)\n    gdf.to_file(geojson_path, driver=\"GeoJSON\")\n    return geojson_path\n</code></pre>"},{"location":"api/#civic_lib_geo.shapefile_utils.load_shapefile","title":"load_shapefile","text":"<pre><code>load_shapefile(path: Path) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Load a shapefile into a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the shapefile (.shp).</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.</p> Source code in <code>src/civic_lib_geo/shapefile_utils.py</code> <pre><code>def load_shapefile(path: Path) -&gt; gpd.GeoDataFrame:\n    \"\"\"Load a shapefile into a GeoDataFrame.\n\n    Args:\n        path (Path): Path to the shapefile (.shp).\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.\n    \"\"\"\n    return gpd.read_file(path)\n</code></pre>"},{"location":"api/#civic_lib_geo.topojson_utils","title":"topojson_utils","text":"<p>civic_lib_geo/topojson_utils.py.</p> <p>TopoJSON utility functions for Civic Interconnect.</p> <p>MIT License \u2014 maintained by Civic Interconnect</p>"},{"location":"api/#civic_lib_geo.topojson_utils.convert_topojson_to_geojson","title":"convert_topojson_to_geojson","text":"<pre><code>convert_topojson_to_geojson(topojson_path: Path, geojson_path: Path) -&gt; Path\n</code></pre> <p>Convert a TopoJSON file to a GeoJSON file using geopandas or CLI tools.</p> Source code in <code>src/civic_lib_geo/topojson_utils.py</code> <pre><code>def convert_topojson_to_geojson(topojson_path: Path, geojson_path: Path) -&gt; Path:\n    \"\"\"Convert a TopoJSON file to a GeoJSON file using geopandas or CLI tools.\"\"\"\n    gdf = gpd.read_file(topojson_path)\n    gdf.to_file(geojson_path, driver=\"GeoJSON\")\n    return geojson_path\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants","title":"us_constants","text":"<p>civic_lib_geo/us_constants.py.</p> <p>US State Code Constants for Civic Interconnect</p> <p>This module defines reusable mappings and lookup records for U.S. state information, including:</p> <ul> <li>2-letter abbreviations</li> <li>Full state names</li> <li>FIPS codes</li> <li>Multiple lookup formats (by name, abbr, FIPS, lowercase)</li> <li>Pre-built record dictionaries and choice lists for UI/display</li> </ul> <p>These constants are used to standardize geodata processing and support consistent reporting.</p>"},{"location":"api/#civic_lib_geo.us_constants.get_state_dir_name","title":"get_state_dir_name","text":"<pre><code>get_state_dir_name(state_abbr: str) -&gt; str\n</code></pre> <p>Return the standardized directory name for a state (full lowercase name with underscores).</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def get_state_dir_name(state_abbr: str) -&gt; str:\n    \"\"\"Return the standardized directory name for a state (full lowercase name with underscores).\"\"\"\n    name = US_STATE_ABBR_TO_NAME[state_abbr]\n    return name.lower().replace(\" \", \"_\")\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants.get_state_record_by_abbr","title":"get_state_record_by_abbr","text":"<pre><code>get_state_record_by_abbr(abbr: str) -&gt; dict | None\n</code></pre> <p>Return state record by 2-letter abbreviation (e.g., 'MN').</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def get_state_record_by_abbr(abbr: str) -&gt; dict | None:\n    \"\"\"Return state record by 2-letter abbreviation (e.g., 'MN').\"\"\"\n    return US_STATE_RECORDS_BY_ABBR.get(abbr.upper())\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants.get_state_record_by_any","title":"get_state_record_by_any","text":"<pre><code>get_state_record_by_any(value: str) -&gt; dict | None\n</code></pre> <p>Return state record by abbr, name, or FIPS code (case-insensitive).</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def get_state_record_by_any(value: str) -&gt; dict | None:\n    \"\"\"Return state record by abbr, name, or FIPS code (case-insensitive).\"\"\"\n    value = value.strip().lower()\n    return (\n        US_STATE_RECORDS_BY_ABBR_LOWER.get(value)\n        or US_STATE_RECORDS_BY_NAME_LOWER.get(value)\n        or US_STATE_RECORDS_BY_FIPS_LOWER.get(value)\n    )\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants.get_state_record_by_fips","title":"get_state_record_by_fips","text":"<pre><code>get_state_record_by_fips(fips: str) -&gt; dict | None\n</code></pre> <p>Return state record by FIPS code (e.g., '27').</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def get_state_record_by_fips(fips: str) -&gt; dict | None:\n    \"\"\"Return state record by FIPS code (e.g., '27').\"\"\"\n    return US_STATE_RECORDS_BY_FIPS.get(fips)\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants.get_state_record_by_name","title":"get_state_record_by_name","text":"<pre><code>get_state_record_by_name(name: str) -&gt; dict | None\n</code></pre> <p>Return state record by full name (e.g., 'Minnesota').</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def get_state_record_by_name(name: str) -&gt; dict | None:\n    \"\"\"Return state record by full name (e.g., 'Minnesota').\"\"\"\n    return US_STATE_RECORDS_BY_NAME.get(name)\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants.list_state_choices","title":"list_state_choices","text":"<pre><code>list_state_choices() -&gt; list[tuple[str, str]]\n</code></pre> <p>Return list of (abbr, name) tuples for all states (for dropdowns/UI).</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def list_state_choices() -&gt; list[tuple[str, str]]:\n    \"\"\"Return list of (abbr, name) tuples for all states (for dropdowns/UI).\"\"\"\n    return US_STATE_CHOICES\n</code></pre>"},{"location":"api/#civic_lib_geo.us_constants.list_state_choices_by_fips","title":"list_state_choices_by_fips","text":"<pre><code>list_state_choices_by_fips() -&gt; list[tuple[str, str]]\n</code></pre> <p>Return list of (FIPS, name) tuples for all states (for dropdowns/UI).</p> Source code in <code>src/civic_lib_geo/us_constants.py</code> <pre><code>def list_state_choices_by_fips() -&gt; list[tuple[str, str]]:\n    \"\"\"Return list of (FIPS, name) tuples for all states (for dropdowns/UI).\"\"\"\n    return US_STATE_CHOICES_BY_FIPS\n</code></pre>"},{"location":"api/civic_lib_geo.cli.check_size/","title":"Module <code>civic_lib_geo.cli.check_size</code>","text":""},{"location":"api/civic_lib_geo.cli.check_size/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.check_size/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.check_size/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.check_size/#get_file_size_mbpath-str-pathlibpath-float","title":"<code>get_file_size_mb(path: str | pathlib.Path) -&gt; float</code>","text":"<p>Return the file size in megabytes (MB).</p> <p>Args:     path: Path to the file.</p> <p>Returns:     File size in megabytes.</p> <p>Raises:     FileNotFoundError: If the file does not exist.</p>"},{"location":"api/civic_lib_geo.cli.check_size/#mainpath-pathlibpath-int","title":"<code>main(path: pathlib.Path) -&gt; int</code>","text":"<p>Print the size of a GeoJSON file and whether it exceeds GitHub Pages limits.</p> <p>Args:     path (Path): Path to the GeoJSON file to inspect.</p> <p>Returns:     int: 0 if OK, 1 if an error occurs.</p>"},{"location":"api/civic_lib_geo.cli.check_size/#needs_chunkingpath-str-pathlibpath-max_mb-float-250-bool","title":"<code>needs_chunking(path: str | pathlib.Path, max_mb: float = 25.0) -&gt; bool</code>","text":"<p>Determine whether the GeoJSON file exceeds the size threshold.</p> <p>Args:     path: Path to the file.     max_mb: Maximum file size before chunking is recommended.</p> <p>Returns:     True if file exceeds max_mb, else False.</p>"},{"location":"api/civic_lib_geo.cli.chunk_geojson/","title":"Module <code>civic_lib_geo.cli.chunk_geojson</code>","text":""},{"location":"api/civic_lib_geo.cli.chunk_geojson/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.chunk_geojson/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.chunk_geojson/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.chunk_geojson/#apply_to_geojson_folderfolder-pathlibpath-action_fn-collectionsabccallable-suffix-str-_processedgeojson-tolerance-float-none-none-max_features-int-none-none","title":"<code>apply_to_geojson_folder(folder: pathlib.Path, action_fn: collections.abc.Callable, *, suffix: str = '_processed.geojson', tolerance: float | None = None, max_features: int | None = None)</code>","text":"<p>Apply an action to every .geojson file in a folder.</p> <p>Args:     folder (Path): Path to folder containing .geojson files.     action_fn (Callable): Function to apply to each file.     suffix (str): Suffix to add to output filenames.     tolerance (float | None): Optional tolerance value for simplification.     max_features (int | None): Optional limit for chunking.</p>"},{"location":"api/civic_lib_geo.cli.chunk_geojson/#chunk_geojson_featuresgeojson-dict-max_features-int-500-output_dir-str-pathlibpath-chunks-base_name-str-chunk-listpathlibpath","title":"<code>chunk_geojson_features(geojson: dict, max_features: int = 500, output_dir: str | pathlib.Path = 'chunks', base_name: str = 'chunk') -&gt; list[pathlib.Path]</code>","text":"<p>Split a GeoJSON FeatureCollection into multiple smaller files.</p> <p>Args:     geojson: Loaded GeoJSON dictionary (must contain a 'features' list).     max_features: Maximum number of features per chunk.     output_dir: Directory to write chunked files to.     base_name: Base filename prefix for each chunk.</p> <p>Returns:     List of Paths to chunked files.</p> <p>Raises:     ValueError: If 'features' is missing or not a list.</p>"},{"location":"api/civic_lib_geo.cli.chunk_geojson/#chunk_onepath-pathlibpath-max_features-int-output_dir-pathlibpath","title":"<code>chunk_one(path: pathlib.Path, max_features: int, output_dir: pathlib.Path)</code>","text":"<p>Chunk a single GeoJSON file and write the output files.</p> <p>Args:     path (Path): Path to input GeoJSON file.     max_features (int): Max features per chunk.     output_dir (Path): Output folder to store chunks.</p>"},{"location":"api/civic_lib_geo.cli.chunk_geojson/#mainpath-pathlibpath-max_features-int-500-output_dir-pathlibpath-windowspathchunks-all_files-bool-false-int","title":"<code>main(path: pathlib.Path, max_features: int = 500, output_dir: pathlib.Path = WindowsPath('chunks'), all_files: bool = False) -&gt; int</code>","text":"<p>Chunk a single file or all .geojson files in a folder.</p> <p>Args:     path (Path): Input file or folder path.     max_features (int): Max features per chunk.     output_dir (Path): Directory to store chunks.     all_files (bool): If True and path is a folder, chunk all files in it.</p> <p>Returns:     int: Exit code, 0 if success, 1 if failure.</p>"},{"location":"api/civic_lib_geo.cli.cli/","title":"Module <code>civic_lib_geo.cli.cli</code>","text":""},{"location":"api/civic_lib_geo.cli.cli/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.cli/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.cli/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.cli/#check_size_commandpath-pathlibpath","title":"<code>check_size_command(path: pathlib.Path)</code>","text":"<p>Report the size of a GeoJSON file and whether it exceeds the GitHub Pages 25MB limit.</p>"},{"location":"api/civic_lib_geo.cli.cli/#chunk_commandfolder-pathlibpath-typermodelsargumentinfo-object-at-0x00000227578dd550-max_features-int-500-single_file-pathlibpath-typermodelsoptioninfo-object-at-0x0000022756f65640","title":"<code>chunk_command(folder: pathlib.Path = &lt;typer.models.ArgumentInfo object at 0x00000227578DD550&gt;, max_features: int = 500, single_file: pathlib.Path = &lt;typer.models.OptionInfo object at 0x0000022756F65640&gt;)</code>","text":"<p>Chunk a GeoJSON file or all files in a folder into smaller files with limited features.</p>"},{"location":"api/civic_lib_geo.cli.cli/#main-int","title":"<code>main() -&gt; int</code>","text":"<p>No description available.</p>"},{"location":"api/civic_lib_geo.cli.cli/#props_commandpath-pathlibpath","title":"<code>props_command(path: pathlib.Path)</code>","text":"<p>Display the property keys from the first feature of a GeoJSON file.</p>"},{"location":"api/civic_lib_geo.cli.cli/#shapefile_to_geojson_commandshp_path-pathlibpath-geojson_path-pathlibpath","title":"<code>shapefile_to_geojson_command(shp_path: pathlib.Path, geojson_path: pathlib.Path)</code>","text":"<p>Convert a shapefile to GeoJSON.</p>"},{"location":"api/civic_lib_geo.cli.cli/#simplify_commandfolder-pathlibpath-typermodelsargumentinfo-object-at-0x00000227578dd550-tolerance-float-001-single_file-pathlibpath-typermodelsoptioninfo-object-at-0x0000022756f65640","title":"<code>simplify_command(folder: pathlib.Path = &lt;typer.models.ArgumentInfo object at 0x00000227578DD550&gt;, tolerance: float = 0.01, single_file: pathlib.Path = &lt;typer.models.OptionInfo object at 0x0000022756F65640&gt;)</code>","text":"<p>Simplify one GeoJSON file or all files in a folder using the given tolerance.</p>"},{"location":"api/civic_lib_geo.cli.cli/#topojson_to_geojson_commandtopo_path-pathlibpath-geojson_path-pathlibpath","title":"<code>topojson_to_geojson_command(topo_path: pathlib.Path, geojson_path: pathlib.Path)</code>","text":"<p>Convert a TopoJSON file to GeoJSON using GeoPandas (if supported).</p>"},{"location":"api/civic_lib_geo.cli.read_props/","title":"Module <code>civic_lib_geo.cli.read_props</code>","text":""},{"location":"api/civic_lib_geo.cli.read_props/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.read_props/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.read_props/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.read_props/#apply_to_geojson_folderfolder-pathlibpath-action_fn-collectionsabccallable-suffix-str-_processedgeojson-tolerance-float-none-none-max_features-int-none-none","title":"<code>apply_to_geojson_folder(folder: pathlib.Path, action_fn: collections.abc.Callable, *, suffix: str = '_processed.geojson', tolerance: float | None = None, max_features: int | None = None)</code>","text":"<p>Apply an action to every .geojson file in a folder.</p> <p>Args:     folder (Path): Path to folder containing .geojson files.     action_fn (Callable): Function to apply to each file.     suffix (str): Suffix to add to output filenames.     tolerance (float | None): Optional tolerance value for simplification.     max_features (int | None): Optional limit for chunking.</p>"},{"location":"api/civic_lib_geo.cli.read_props/#mainpath-pathlibpath-all_files-bool-false-int","title":"<code>main(path: pathlib.Path, all_files: bool = False) -&gt; int</code>","text":"<p>Display feature properties for a single file or all .geojson files in a folder.</p> <p>Args:     path (Path): File or folder path.     all_files (bool): If True and path is a folder, process all .geojson files inside.</p> <p>Returns:     int: 0 if success, 1 on error.</p>"},{"location":"api/civic_lib_geo.cli.read_props/#read_geojson_propspath-pathlibpath-listdictstr-typingany","title":"<code>read_geojson_props(path: pathlib.Path) -&gt; list[dict[str, typing.Any]]</code>","text":"<p>Load only the properties from a GeoJSON file.</p> <p>Args:     path (Path): Path to the GeoJSON file.</p> <p>Returns:     list[dict[str, Any]]: A list of property dictionaries from each feature.</p>"},{"location":"api/civic_lib_geo.cli.read_props/#read_props_onepath-pathlibpath-output-pathlibpath-none-none-max_rows-int-5","title":"<code>read_props_one(path: pathlib.Path, output: pathlib.Path | None = None, max_rows: int = 5)</code>","text":"<p>Print properties from the first few features in a GeoJSON file.</p> <p>Args:     path (Path): Path to the GeoJSON file.     output (Path | None): Ignored in this function (kept for compatibility).     max_rows (int): Number of feature properties to preview.</p>"},{"location":"api/civic_lib_geo.cli.shapefile_to_geojson/","title":"Module <code>civic_lib_geo.cli.shapefile_to_geojson</code>","text":""},{"location":"api/civic_lib_geo.cli.shapefile_to_geojson/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.shapefile_to_geojson/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.shapefile_to_geojson/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.shapefile_to_geojson/#mainshp_path-pathlibpath-geojson_path-pathlibpath-int","title":"<code>main(shp_path: pathlib.Path, geojson_path: pathlib.Path) -&gt; int</code>","text":"<p>Convert a shapefile to GeoJSON.</p> <p>Args:     shp_path (Path): Input .shp file path.     geojson_path (Path): Output .geojson file path.</p> <p>Returns:     int: 0 if success, 1 on error.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/","title":"Module <code>civic_lib_geo.cli.simplify_geojson</code>","text":""},{"location":"api/civic_lib_geo.cli.simplify_geojson/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.simplify_geojson/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.simplify_geojson/#apply_to_geojson_folderfolder-pathlibpath-action_fn-collectionsabccallable-suffix-str-_processedgeojson-tolerance-float-none-none-max_features-int-none-none","title":"<code>apply_to_geojson_folder(folder: pathlib.Path, action_fn: collections.abc.Callable, *, suffix: str = '_processed.geojson', tolerance: float | None = None, max_features: int | None = None)</code>","text":"<p>Apply an action to every .geojson file in a folder.</p> <p>Args:     folder (Path): Path to folder containing .geojson files.     action_fn (Callable): Function to apply to each file.     suffix (str): Suffix to add to output filenames.     tolerance (float | None): Optional tolerance value for simplification.     max_features (int | None): Optional limit for chunking.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/#load_geojsonpath-pathlibpath-geopandasgeodataframegeodataframe","title":"<code>load_geojson(path: pathlib.Path) -&gt; geopandas.geodataframe.GeoDataFrame</code>","text":"<p>Load a GeoJSON file into a GeoDataFrame.</p> <p>Args:     path (Path): Path to the GeoJSON file.</p> <p>Returns:     gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/#mainpath-pathlibpath-tolerance-float-001-output-pathlibpath-none-none-all_files-bool-false","title":"<code>main(path: pathlib.Path, tolerance: float = 0.01, output: pathlib.Path | None = None, all_files: bool = False)</code>","text":"<p>Simplify a single file or all .geojson files in a folder.</p> <p>Args:     path (Path): Input file or folder.     tolerance (float): Simplification tolerance.     output (Path | None): Output file path for single file use.     all_files (bool): If True and path is a folder, simplify all .geojson files.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/#save_geojsongdf-gpdgeodataframe-path-pathlibpath-indent-int-2-pathlibpath","title":"<code>save_geojson(gdf: 'gpd.GeoDataFrame', path: pathlib.Path, indent: int = 2) -&gt; pathlib.Path</code>","text":"<p>Save a GeoDataFrame to GeoJSON format.</p> <p>Args:     gdf (gpd.GeoDataFrame): The GeoDataFrame to save.     path (Path): Output file path.     indent (int): Indentation level for formatting (unused by GeoPandas but included for consistency).</p> <p>Returns:     Path: The path to the saved file.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/#simplify_geojsongdf-geopandasgeodataframegeodataframe-tolerance-float-geopandasgeodataframegeodataframe","title":"<code>simplify_geojson(gdf: geopandas.geodataframe.GeoDataFrame, tolerance: float) -&gt; geopandas.geodataframe.GeoDataFrame</code>","text":"<p>Return a simplified copy of the GeoDataFrame using the given tolerance.</p> <p>Args:     gdf (gpd.GeoDataFrame): The input GeoDataFrame.     tolerance (float): Tolerance for simplification (smaller values retain more detail).</p> <p>Returns:     gpd.GeoDataFrame: A new GeoDataFrame with simplified geometry.</p>"},{"location":"api/civic_lib_geo.cli.simplify_geojson/#simplify_onepath-pathlibpath-tolerance-float-output-pathlibpath","title":"<code>simplify_one(path: pathlib.Path, tolerance: float, output: pathlib.Path)</code>","text":"<p>Simplify a single GeoJSON file and write the output.</p> <p>Args:     path (Path): Path to the original GeoJSON file.     tolerance (float): Tolerance for simplification.     output (Path): Output path for the simplified file.</p>"},{"location":"api/civic_lib_geo.cli.topojson_to_geojson/","title":"Module <code>civic_lib_geo.cli.topojson_to_geojson</code>","text":""},{"location":"api/civic_lib_geo.cli.topojson_to_geojson/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.cli.topojson_to_geojson/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.cli.topojson_to_geojson/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.cli.topojson_to_geojson/#maintopo_path-pathlibpath-geojson_path-pathlibpath-int","title":"<code>main(topo_path: pathlib.Path, geojson_path: pathlib.Path) -&gt; int</code>","text":"<p>Convert a TopoJSON file to GeoJSON using GeoPandas (if supported).</p> <p>Args:     topo_path (Path): Input .topojson file path.     geojson_path (Path): Output .geojson file path.</p> <p>Returns:     int: 0 if success, 1 if failure.</p>"},{"location":"api/civic_lib_geo.fips_utils/","title":"Module <code>civic_lib_geo.fips_utils</code>","text":""},{"location":"api/civic_lib_geo.fips_utils/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.fips_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.fips_utils/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.fips_utils/#get_fips_by_state_codestate_code-str-source-pathlibpath-none-none-str","title":"<code>get_fips_by_state_code(state_code: str, source: pathlib.Path | None = None) -&gt; str</code>","text":"<p>Returns the FIPS code for a given 2-letter state code.</p> <p>Args:     state_code (str): A 2-letter state abbreviation (e.g., 'MN').     source (Path | None): Optional override path to a custom CSV file.</p> <p>Returns:     str: Corresponding FIPS code (e.g., '27').</p> <p>Raises:     ValueError: If the state code is not found.</p>"},{"location":"api/civic_lib_geo.fips_utils/#get_state_fips_dfsource-pathlibpath-none-none-pandascoreframedataframe","title":"<code>get_state_fips_df(source: pathlib.Path | None = None) -&gt; pandas.core.frame.DataFrame</code>","text":"<p>Load and return a DataFrame of US state FIPS codes.</p> <p>Args:     source (Path | None): Path to a CSV file. If None, uses the default embedded CSV.</p> <p>Returns:     pd.DataFrame: A DataFrame with columns ['state_code', 'state_name', 'fips_code'].</p>"},{"location":"api/civic_lib_geo.fips_utils/#get_state_name_by_codestate_code-str-source-pathlibpath-none-none-str","title":"<code>get_state_name_by_code(state_code: str, source: pathlib.Path | None = None) -&gt; str</code>","text":"<p>Returns the full state name for a given 2-letter state code.</p> <p>Args:     state_code (str): A 2-letter state abbreviation.     source (Path | None): Optional override path to a custom CSV file.</p> <p>Returns:     str: Full state name (e.g., 'Minnesota').</p> <p>Raises:     ValueError: If the state code is not found.</p>"},{"location":"api/civic_lib_geo.fips_utils/#read_csv_from_pathsource-pathlibpath-pandascoreframedataframe","title":"<code>read_csv_from_path(source: pathlib.Path) -&gt; pandas.core.frame.DataFrame</code>","text":"<p>Reads a CSV file from the given path and returns a DataFrame.</p> <p>Args:     source (Path): Path to the CSV file.</p> <p>Returns:     pd.DataFrame: DataFrame containing the CSV data.</p>"},{"location":"api/civic_lib_geo.geojson_utils/","title":"Module <code>civic_lib_geo.geojson_utils</code>","text":""},{"location":"api/civic_lib_geo.geojson_utils/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.geojson_utils/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#callableself-args-kwargs","title":"<code>Callable(self, /, *args, **kwargs)</code>","text":"<p>No description available.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.geojson_utils/#apply_to_geojson_folderfolder-pathlibpath-action_fn-collectionsabccallable-suffix-str-_processedgeojson-tolerance-float-none-none-max_features-int-none-none","title":"<code>apply_to_geojson_folder(folder: pathlib.Path, action_fn: collections.abc.Callable, *, suffix: str = '_processed.geojson', tolerance: float | None = None, max_features: int | None = None)</code>","text":"<p>Apply an action to every .geojson file in a folder.</p> <p>Args:     folder (Path): Path to folder containing .geojson files.     action_fn (Callable): Function to apply to each file.     suffix (str): Suffix to add to output filenames.     tolerance (float | None): Optional tolerance value for simplification.     max_features (int | None): Optional limit for chunking.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#chunk_geojson_featuresgeojson-dict-max_features-int-500-output_dir-str-pathlibpath-chunks-base_name-str-chunk-listpathlibpath","title":"<code>chunk_geojson_features(geojson: dict, max_features: int = 500, output_dir: str | pathlib.Path = 'chunks', base_name: str = 'chunk') -&gt; list[pathlib.Path]</code>","text":"<p>Split a GeoJSON FeatureCollection into multiple smaller files.</p> <p>Args:     geojson: Loaded GeoJSON dictionary (must contain a 'features' list).     max_features: Maximum number of features per chunk.     output_dir: Directory to write chunked files to.     base_name: Base filename prefix for each chunk.</p> <p>Returns:     List of Paths to chunked files.</p> <p>Raises:     ValueError: If 'features' is missing or not a list.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#get_file_size_mbpath-str-pathlibpath-float","title":"<code>get_file_size_mb(path: str | pathlib.Path) -&gt; float</code>","text":"<p>Return the file size in megabytes (MB).</p> <p>Args:     path: Path to the file.</p> <p>Returns:     File size in megabytes.</p> <p>Raises:     FileNotFoundError: If the file does not exist.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#is_valid_geojson_feature_collectionobj-dict-bool","title":"<code>is_valid_geojson_feature_collection(obj: dict) -&gt; bool</code>","text":"<p>Quick check if an object looks like a valid GeoJSON FeatureCollection.</p> <p>Args:     obj: Dictionary to check.</p> <p>Returns:     True if valid structure, else False.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#list_geojson_filesfolder-pathlibpath-listpathlibpath","title":"<code>list_geojson_files(folder: pathlib.Path) -&gt; list[pathlib.Path]</code>","text":"<p>Return a list of .geojson files in the specified folder.</p> <p>Args:     folder (Path): Directory to search.</p> <p>Returns:     list[Path]: List of .geojson file paths.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#load_geojsonpath-pathlibpath-geopandasgeodataframegeodataframe","title":"<code>load_geojson(path: pathlib.Path) -&gt; geopandas.geodataframe.GeoDataFrame</code>","text":"<p>Load a GeoJSON file into a GeoDataFrame.</p> <p>Args:     path (Path): Path to the GeoJSON file.</p> <p>Returns:     gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#needs_chunkingpath-str-pathlibpath-max_mb-float-250-bool","title":"<code>needs_chunking(path: str | pathlib.Path, max_mb: float = 25.0) -&gt; bool</code>","text":"<p>Determine whether the GeoJSON file exceeds the size threshold.</p> <p>Args:     path: Path to the file.     max_mb: Maximum file size before chunking is recommended.</p> <p>Returns:     True if file exceeds max_mb, else False.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#read_geojson_propspath-pathlibpath-listdictstr-typingany","title":"<code>read_geojson_props(path: pathlib.Path) -&gt; list[dict[str, typing.Any]]</code>","text":"<p>Load only the properties from a GeoJSON file.</p> <p>Args:     path (Path): Path to the GeoJSON file.</p> <p>Returns:     list[dict[str, Any]]: A list of property dictionaries from each feature.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#save_geojsongdf-gpdgeodataframe-path-pathlibpath-indent-int-2-pathlibpath","title":"<code>save_geojson(gdf: 'gpd.GeoDataFrame', path: pathlib.Path, indent: int = 2) -&gt; pathlib.Path</code>","text":"<p>Save a GeoDataFrame to GeoJSON format.</p> <p>Args:     gdf (gpd.GeoDataFrame): The GeoDataFrame to save.     path (Path): Output file path.     indent (int): Indentation level for formatting (unused by GeoPandas but included for consistency).</p> <p>Returns:     Path: The path to the saved file.</p>"},{"location":"api/civic_lib_geo.geojson_utils/#simplify_geojsongdf-geopandasgeodataframegeodataframe-tolerance-float-geopandasgeodataframegeodataframe","title":"<code>simplify_geojson(gdf: geopandas.geodataframe.GeoDataFrame, tolerance: float) -&gt; geopandas.geodataframe.GeoDataFrame</code>","text":"<p>Return a simplified copy of the GeoDataFrame using the given tolerance.</p> <p>Args:     gdf (gpd.GeoDataFrame): The input GeoDataFrame.     tolerance (float): Tolerance for simplification (smaller values retain more detail).</p> <p>Returns:     gpd.GeoDataFrame: A new GeoDataFrame with simplified geometry.</p>"},{"location":"api/civic_lib_geo.shapefile_utils/","title":"Module <code>civic_lib_geo.shapefile_utils</code>","text":""},{"location":"api/civic_lib_geo.shapefile_utils/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.shapefile_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.shapefile_utils/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.shapefile_utils/#convert_shapefile_to_geojsonshp_path-pathlibpath-geojson_path-pathlibpath-pathlibpath","title":"<code>convert_shapefile_to_geojson(shp_path: pathlib.Path, geojson_path: pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Convert a shapefile to a GeoJSON file.</p> <p>Args:     shp_path (Path): Path to the source shapefile (.shp).     geojson_path (Path): Path to the output GeoJSON file.</p> <p>Returns:     Path: The path to the saved GeoJSON file.</p>"},{"location":"api/civic_lib_geo.shapefile_utils/#load_shapefilepath-pathlibpath-geopandasgeodataframegeodataframe","title":"<code>load_shapefile(path: pathlib.Path) -&gt; geopandas.geodataframe.GeoDataFrame</code>","text":"<p>Load a shapefile into a GeoDataFrame.</p> <p>Args:     path (Path): Path to the shapefile (.shp).</p> <p>Returns:     gpd.GeoDataFrame: A GeoDataFrame with geometries and attributes.</p>"},{"location":"api/civic_lib_geo.topojson_utils/","title":"Module <code>civic_lib_geo.topojson_utils</code>","text":""},{"location":"api/civic_lib_geo.topojson_utils/#classes","title":"Classes","text":""},{"location":"api/civic_lib_geo.topojson_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/civic_lib_geo.topojson_utils/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.topojson_utils/#convert_topojson_to_geojsontopojson_path-pathlibpath-geojson_path-pathlibpath-pathlibpath","title":"<code>convert_topojson_to_geojson(topojson_path: pathlib.Path, geojson_path: pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Convert a TopoJSON file to a GeoJSON file using geopandas or CLI tools.</p>"},{"location":"api/civic_lib_geo.us_constants/","title":"Module <code>civic_lib_geo.us_constants</code>","text":""},{"location":"api/civic_lib_geo.us_constants/#functions","title":"Functions","text":""},{"location":"api/civic_lib_geo.us_constants/#get_state_dir_namestate_abbr-str-str","title":"<code>get_state_dir_name(state_abbr: str) -&gt; str</code>","text":"<p>Return the standardized directory name for a state (full lowercase name with underscores).</p>"},{"location":"api/civic_lib_geo.us_constants/#get_state_record_by_abbrabbr-str-dict-none","title":"<code>get_state_record_by_abbr(abbr: str) -&gt; dict | None</code>","text":"<p>Return state record by 2-letter abbreviation (e.g., 'MN').</p>"},{"location":"api/civic_lib_geo.us_constants/#get_state_record_by_anyvalue-str-dict-none","title":"<code>get_state_record_by_any(value: str) -&gt; dict | None</code>","text":"<p>Return state record by abbr, name, or FIPS code (case-insensitive).</p>"},{"location":"api/civic_lib_geo.us_constants/#get_state_record_by_fipsfips-str-dict-none","title":"<code>get_state_record_by_fips(fips: str) -&gt; dict | None</code>","text":"<p>Return state record by FIPS code (e.g., '27').</p>"},{"location":"api/civic_lib_geo.us_constants/#get_state_record_by_namename-str-dict-none","title":"<code>get_state_record_by_name(name: str) -&gt; dict | None</code>","text":"<p>Return state record by full name (e.g., 'Minnesota').</p>"},{"location":"api/civic_lib_geo.us_constants/#list_state_choices-listtuplestr-str","title":"<code>list_state_choices() -&gt; list[tuple[str, str]]</code>","text":"<p>Return list of (abbr, name) tuples for all states (for dropdowns/UI).</p>"},{"location":"api/civic_lib_geo.us_constants/#list_state_choices_by_fips-listtuplestr-str","title":"<code>list_state_choices_by_fips() -&gt; list[tuple[str, str]]</code>","text":"<p>Return list of (FIPS, name) tuples for all states (for dropdowns/UI).</p>"}]}